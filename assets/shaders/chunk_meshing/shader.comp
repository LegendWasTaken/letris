#version 460

layout(std430, binding = 0) buffer faces_buffer {
    ivec4 faces[];
};

layout (std430, binding = 1) buffer counter_buffer {
    uint vertex_count;
    uint instanceCount;
    uint FirstIndex;
    int baseIndex;
    uint reservedMustBeZero;
};

layout (std430, binding = 2) buffer block_buffer {
    uint blocks[16 * 256 * 16];
};

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#define FN 0
#define FS 1
#define FW 2
#define FE 3
#define FU 4
#define FD 5

ivec4 make_face(uint direction, uint id, ivec3 block_pos)
{
    uint meta = (direction << 12) & uint(0xF000);
    meta |= (id << 16) & uint(0xFFFF0000);

    return ivec4(block_pos, meta);
}

void main() {
    ivec3 bp = ivec3(gl_GlobalInvocationID);
    uint block = blocks[(bp.y & 0xF) << 8 | (bp.z & 0xF) << 4 | (bp.x & 0xF)];
    uint seed = (block & uint(0xFFFF0000)) >> 16;
    uint id = seed;

    bool is_not_air = id != 0;

    bool valid_faces[6];
    valid_faces[FN] = bool(block & uint(0x8000)) && is_not_air;
    valid_faces[FS] = bool(block & uint(0x4000)) && is_not_air;
    valid_faces[FW] = bool(block & uint(0x2000)) && is_not_air;
    valid_faces[FE] = bool(block & uint(0x1000)) && is_not_air;
    valid_faces[FU] = bool(block & uint(0x800)) && is_not_air;
    valid_faces[FD] = bool(block & uint(0x400)) && is_not_air;

    uint out_face_size = 0;
    ivec4 out_faces[6];

    if (valid_faces[FN]) out_faces[out_face_size++] = make_face(FN, id, bp);
    if (valid_faces[FS]) out_faces[out_face_size++] = make_face(FS, id, bp);
    if (valid_faces[FW]) out_faces[out_face_size++] = make_face(FW, id, bp);
    if (valid_faces[FE]) out_faces[out_face_size++] = make_face(FE, id, bp);
    if (valid_faces[FU]) out_faces[out_face_size++] = make_face(FU, id, bp);
    if (valid_faces[FD]) out_faces[out_face_size++] = make_face(FD, id, bp);

    uint current_face_size = atomicAdd(vertex_count, out_face_size * 6) / 6;

    for (int i = 0; i < out_face_size; i++)
        faces[i + current_face_size] = out_faces[i];
}
