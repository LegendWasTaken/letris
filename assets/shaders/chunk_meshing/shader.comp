#version 460

struct Vertex {
    vec4 position;
    vec4 normal;
    vec4 colour;
};

layout(std430, binding = 0) buffer data_buffer {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer indices_buffer {
    uint indices[];
};

layout (std430, binding = 2) buffer counter_buffer {
    uint count;
    uint instanceCount;
    uint FirstIndex;
    int baseIndex;
    uint reservedMustBeZero;
    uint vertex_count;
};

layout (std430, binding = 3) buffer block_buffer {
    uint blocks[16 * 16 * 16];
};

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#define ITNNV 0
#define ITNPV 1
#define ITPNV 2
#define ITPPV 3
#define IBNPV 4
#define IBNNV 5
#define IBPPV 6
#define IBPNV 7

vec3 CVS[8] = {
vec3(0, 1, 0),
vec3(0, 1, 1),
vec3(1, 1, 0),
vec3(1, 1, 1),
vec3(0, 0, 0),
vec3(0, 0, 1),
vec3(1, 0, 0),
vec3(1, 0, 1),
};

#define FN 0
#define FS 1
#define FW 2
#define FE 3
#define FU 4
#define FD 5

vec3 NORMAL_LUT[6] = {
    vec3( 0, -1,  0),
    vec3( 0,  1,  0),
    vec3( 0,  0,  1),
    vec3( 0,  0, -1),
    vec3( 1,  0,  0),
    vec3(-1,  0,  0),
};

uint cube_verts_size = 0;
vec4 cube_verts[24] = {
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
    vec4(0),
};

uint cube_indices_size = 0;
uint cube_indices[24] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

uint insert_vertex(uint vert_type, uint normal) {
    vec3 vert = CVS[vert_type];
    cube_verts[cube_verts_size++] = vec4(vert, uintBitsToFloat(normal));
    return cube_verts_size - 1;
}

void insert_index(uint index) {
    cube_indices[cube_indices_size++] = index;
}

void main() {
    ivec3 bp = ivec3(gl_GlobalInvocationID);
    uint block = blocks[(bp.y & 0xF) << 8 | (bp.z & 0xF) << 4 | (bp.x & 0xF)];
    uint seed = (block & uint(0xFFFF0000)) >> 16;
    uint id = seed;

    bool is_not_air = id != 0;

    bool faces[6];
    faces[FN] = bool(block & uint(0x8000)) && is_not_air;
    faces[FS] = bool(block & uint(0x4000)) && is_not_air;
    faces[FW] = bool(block & uint(0x2000)) && is_not_air;
    faces[FE] = bool(block & uint(0x1000)) && is_not_air;
    faces[FU] = bool(block & uint(0x800)) && is_not_air;
    faces[FD] = bool(block & uint(0x400)) && is_not_air;

    if (faces[FN]) {
        uint IBXX = insert_vertex(IBPNV, FN);
        uint IBXY = insert_vertex(IBNNV, FN);
        uint IBYX = insert_vertex(ITPPV, FN);
        uint IBYY = insert_vertex(ITNPV, FN);

        insert_index(IBXY);
        insert_index(IBXX);
        insert_index(IBYX);

        insert_index(IBYY);
        insert_index(IBXY);
        insert_index(IBYX);
    }

    if (faces[FS]) {
        uint ITXX = insert_vertex(IBPPV, FS);
        uint ITXY = insert_vertex(IBNPV, FS);
        uint ITYX = insert_vertex(ITPNV, FS);
        uint ITYY = insert_vertex(ITNNV, FS);

        insert_index(ITXX);
        insert_index(ITXY);
        insert_index(ITYX);

        insert_index(ITXY);
        insert_index(ITYY);
        insert_index(ITYX);
    }

    if (faces[FW]) {
        uint ITXY = insert_vertex(IBPPV, FW);
        uint ITYY = insert_vertex(IBPNV, FW);
        uint IBXY = insert_vertex(ITPPV, FW);
        uint IBYY = insert_vertex(ITPNV, FW);

        insert_index(ITYY);
        insert_index(ITXY);
        insert_index(IBYY);

        insert_index(ITYY);
        insert_index(IBYY);
        insert_index(IBXY);
    }

    if (faces[FE]) {
        uint ITXX = insert_vertex(IBNPV, FE);
        uint ITYX = insert_vertex(IBNNV, FE);
        uint IBXX = insert_vertex(ITNPV, FE);
        uint IBYX = insert_vertex(ITNNV, FE);

        insert_index(ITXX);
        insert_index(ITYX);
        insert_index(IBYX);

        insert_index(IBYX);
        insert_index(ITYX);
        insert_index(IBXX);
    }

    if (faces[FU]) {
        uint ITYX = insert_vertex(ITNNV, FU);
        uint ITYY = insert_vertex(ITNPV, FU);
        uint IBYX = insert_vertex(ITPNV, FU);
        uint IBYY = insert_vertex(ITPPV, FU);

        insert_index(ITYX);
        insert_index(ITYY);
        insert_index(IBYX);

        insert_index(ITYY);
        insert_index(IBYY);
        insert_index(IBYX);
    }

    if (faces[FD]) {
        uint ITXX = insert_vertex(IBNNV, FD);
        uint ITXY = insert_vertex(IBNPV, FD);
        uint IBXX = insert_vertex(IBPNV, FD);
        uint IBXY = insert_vertex(IBPPV, FD);

        insert_index(ITXX);
        insert_index(ITXY);
        insert_index(IBXX);

        insert_index(ITXY);
        insert_index(IBXY);
        insert_index(IBXX);
    }


    uint current_vertex_size = atomicAdd(vertex_count, cube_verts_size);
    seed = (seed ^ uint(61)) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    vec3 col;
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    col.x = float(seed) / 4294967296.0;
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    col.y = float(seed) / 4294967296.0;
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    col.z = float(seed) / 4294967296.0;

    for (int i = 0; i < cube_verts_size; i++)
    {
        vec4 vertex = cube_verts[i];
        vec3 pos = vertex.xyz + gl_GlobalInvocationID.xyz;
        vec3 normal = NORMAL_LUT[floatBitsToUint(vertex.w)];
        vertices[i + current_vertex_size].position = vec4(pos, 1.0f);
        vertices[i + current_vertex_size].normal = vec4(normal, 1.0f);
        vertices[i + current_vertex_size].colour = vec4(col, 1.0f);
    }

    uint current_index = atomicAdd(count, cube_indices_size);
    for (int i = 0; i < cube_indices_size; i++)
    {
        indices[i + current_index] = cube_indices[i] + current_vertex_size;
    }
}
