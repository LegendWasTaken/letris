#version 460

layout(std430, binding = 0) buffer faces_buffer {
    uint faces[];
};

struct indirect_data {
    uint vertex_count;
    uint instanceCount;
    uint FirstIndex;
    uint baseIndex;
};

layout (std430, binding = 1) buffer counter_buffer {
    indirect_data indirects[];
};

layout (std430, binding = 2) buffer block_buffer {
    uint blocks[];
};

layout (std430, binding = 3) buffer index_buffer {
    uint chunk_face_indices[];
};

layout(local_size_x = 16, local_size_y = 8, local_size_z = 8) in;

#define FN 0
#define FS 1
#define FW 2
#define FE 3
#define FU 4
#define FD 5

// blocks
// 0bXXXX'YYYY'YYYYY'ZZZZ'DIRI'IIII'IIIM'MMM0

uint make_face(uint direction, uint id, ivec3 block_pos)
{
    uint block_id = id >> 4;
    uint block_meta = id & uint(0xF);

    uint block = 0;
    block |= uint((block_pos.x & 0xF) << 28);
    block |= uint((block_pos.y & 0xFF) << 20);
    block |= uint((block_pos.z & 0xF) << 16);
    block |= uint((direction & uint(0x7)) << 13);
    block |= uint((block_id & uint(0xFF)) << 5);
    block |= uint((block_meta & uint(0xF)) << 1);

    return block;
}
ivec4 make_face4(uint direction, uint id, ivec3 block_pos)
{
    uint meta = (direction << 12) & uint(0xF000);
    meta |= (id << 16) & uint(0xFFFF0000);

    return ivec4(block_pos, meta);
}
int face_count(uint block)
{
    int total = 0;
    uint id = (block & uint(0xFFFF0000)) >> 16;
    bool is_not_air = id != 0;
    total += int(bool(block & uint(0x8000)) && is_not_air);
    total += int(bool(block & uint(0x4000)) && is_not_air);
    total += int(bool(block & uint(0x2000)) && is_not_air);
    total += int(bool(block & uint(0x1000)) && is_not_air);
    total += int(bool(block & uint(0x800)) && is_not_air);
    total += int(bool(block & uint(0x400)) && is_not_air);
    return total;
}

void write_faces(uint index, uint block, ivec3 bp)
{
    uint id = (block & uint(0xFFFF0000)) >> 16;

    bool is_not_air = id != 0;

    bool valid_faces[6];
    valid_faces[FN] = bool(block & uint(0x8000)) && is_not_air;
    valid_faces[FS] = bool(block & uint(0x4000)) && is_not_air;
    valid_faces[FW] = bool(block & uint(0x2000)) && is_not_air;
    valid_faces[FE] = bool(block & uint(0x1000)) && is_not_air;
    valid_faces[FU] = bool(block & uint(0x800)) && is_not_air;
    valid_faces[FD] = bool(block & uint(0x400)) && is_not_air;

    if (valid_faces[FN]) faces[index++] = make_face(FN, id, bp);
    if (valid_faces[FS]) faces[index++] = make_face(FS, id, bp);
    if (valid_faces[FW]) faces[index++] = make_face(FW, id, bp);
    if (valid_faces[FE]) faces[index++] = make_face(FE, id, bp);
    if (valid_faces[FU]) faces[index++] = make_face(FU, id, bp);
    if (valid_faces[FD]) faces[index++] = make_face(FD, id, bp);
}

shared uint shared_vertex_count = 0;
shared uint shared_buffer_index = 0;

uint get_block(ivec3 bp)
{
    ivec3 block_pos;
    block_pos.x = bp.x % 16;
    block_pos.y = bp.y;
    block_pos.z = bp.z;
    int offset = int(bp.x / 16);

    return blocks[(offset * 16 * 256 * 16) + ((block_pos.y & 0xFF) << 8 | (block_pos.z & 0xF) << 4 | (block_pos.x & 0xF))];
}

void main() {
    ivec3 bp = ivec3(gl_GlobalInvocationID);

    uint block = get_block(bp);

    int total_face_count = face_count(block);

    uint group_local_offset = atomicAdd(shared_vertex_count, total_face_count * 6) / 6;
    barrier();
    memoryBarrierShared();
    if (gl_LocalInvocationIndex == 0) {
        uint index = chunk_face_indices[bp.x / 16] / 196608;
        shared_buffer_index = atomicAdd(indirects[index].vertex_count, shared_vertex_count) / 6;
    }
    barrier();
    memoryBarrierShared();

    write_faces(shared_buffer_index + group_local_offset + chunk_face_indices[bp.x / 16], block, bp);
}
